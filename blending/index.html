<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Blending In With The Homies</title>
  <link rel="icon" type="image/x-icon" href="images/icon.png" />
  <style>
    html, body { height: 100%; margin: 0; background: #000; }
    #wrap { display:flex; align-items:center; justify-content:center; height:100%; }
    canvas { background:#000; image-rendering: pixelated; }
    @font-face { font-family: 'FATASSFI'; src: url('fonts/FATASSFI.TTF') format('truetype'); font-display: swap; }
    @font-face { font-family: 'FATASSOU'; src: url('fonts/FATASSOU.TTF') format('truetype'); font-display: swap; }
    @font-face { font-family: 'SEGOEPRB'; src: url('fonts/SEGOEPRB.TTF') format('truetype'); font-display: swap; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="1280" height="720"></canvas>
  </div>

  <script>

const rndInt = (min, max) => (min + Math.floor(Math.random() * (max - min + 1)));
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp  = (a, b, t) => a + (b - a) * t;

class TweenManager {
  constructor(){ this.tweens = new Set(); }
  tween(duration, target, toMap, easing = 'linear', onDone){
    const from = {}; const to = {}; const keys = Object.keys(toMap);
    keys.forEach(k => { from[k] = target[k]; to[k] = toMap[k]; });
    const ease = TweenManager.EASING[easing] || TweenManager.EASING.linear;
    const tw = { t:0, d:Math.max(0.0001, duration), target, from, to, keys, ease, onDone, canceled:false };
    this.tweens.add(tw); return tw;
  }
  cancel(tw){ if(tw) tw.canceled = true; }
  after(delay, fn){
    return this.tween(delay, { __dummy:0 }, { __dummy:1 }, 'linear', fn);
  }
  update(dt){
    for(const tw of Array.from(this.tweens)){
      if(tw.canceled){ this.tweens.delete(tw); continue; }
      tw.t += dt;
      const p = clamp(tw.t / tw.d, 0, 1);
      const e = tw.ease(p);
      for(const k of tw.keys){ tw.target[k] = lerp(tw.from[k], tw.to[k], e); }
      if(p >= 1){
        this.tweens.delete(tw);
        if(typeof tw.onDone === 'function') tw.onDone();
      }
    }
  }
}
TweenManager.EASING = {
  linear: t => t,
  'out-quad': t => 1 - (1 - t) * (1 - t),
  'in-out-quad': t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  'in-expo': t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  'out-expo': t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  'in-back': t => {
    const s = 1.5;
    return t * t * ((s + 1) * t - s);
  },
  'out-back': t => {
    const s = 1.5;
    return (t = t - 1) * t * ((s + 1) * t + s) + 1;
  }
};
const Timer = new TweenManager();

class Input {
  constructor(){
    this.curr = new Set();
    this.prev = new Set();
    window.addEventListener('keydown', e => { this.curr.add(e.key.toLowerCase()); });
    window.addEventListener('keyup',   e => { this.curr.delete(e.key.toLowerCase()); });
  }
  update(){ this.prev = new Set(this.curr); }
  pressed(key){ key = key.toLowerCase(); return this.curr.has(key) && !this._prevHas(key); }
  _prevHas(key){ return this.prev.has(key); }
}
const input = new Input();

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let dpr = window.devicePixelRatio || 1;
function resize(){
  const w = 1280, h = 720;
  const ww = window.innerWidth, wh = window.innerHeight;
  const scale = Math.min(ww / w, wh / h);
  canvas.style.width  = (w * scale) + 'px';
  canvas.style.height = (h * scale) + 'px';
}
window.addEventListener('resize', resize);
resize();

function loadImage(src){ return new Promise(res => { const i = new Image(); i.src = src; i.onload = () => res(i); i.onerror = () => res(null); }); }
function loadAudio(src, volume=1){ const a = new Audio(src); a.preload = 'auto'; a.volume = volume; return a; }

const assets = {
  homie: 'images/homie.png',
  homer: 'images/homer.png',
  peter: 'images/peter.png',
  frank: 'images/frank.png',
  chicken: 'images/chicken.png',
  testGraphic: 'images/blendingIn.png',
  background: 'images/bg.png',
  healthIcon: 'images/hp.png',
  comboShatter: 'images/particles/comboShatter.png',
  peterBonus: 'images/peterBonus.png',
  sounds: {
    homerLaugh: 'sounds/homerLaugh.mp3',
    lucky: 'sounds/lucky.mp3',
    notsolucky: 'sounds/notsolucky.ogg',
    grrr: 'sounds/GRRR.mp3',
    priceIsRightLose: 'sounds/priceIsRightLose.mp3',
    frankGrimes: 'sounds/frankGrimes.mp3'
  },
  tutorial: 'images/tutorialScreen.png'
};

const img = {};
const snd = {};

async function preload(){
  const entries = Object.entries(assets).filter(([k]) => k !== 'sounds');
  for (const [k, src] of entries){ img[k] = await loadImage(src); }
  snd.homerLaugh = loadAudio(assets.sounds.homerLaugh, 1);
  snd.lucky = loadAudio(assets.sounds.lucky, 1);
  snd.notsolucky = loadAudio(assets.sounds.notsolucky, 1);
  snd.priceIsRightLose = loadAudio(assets.sounds.priceIsRightLose, 1);
  snd.frankGrimes = loadAudio(assets.sounds.frankGrimes, 1);
  snd.grrr = loadAudio(assets.sounds.grrr, 1);

  snd.frankGrimes.volume = 0.5
  snd.lucky.volume = 0.3;
  snd.notsolucky.volume = 0.3;
  snd.grrr.volume = 0.25
}

let gameoverScreen = false;
let title = true;
let highScore = Number(localStorage.getItem('hh_highScore') || 0);
let diedBy = 'error- diedBy was never set';

let peterBonusPos = [-1000, 130, -35];
let score = 0;
let combo = 0;
let highestCombo = 0;
let comboTilt = 0;
let shakeIntensity = 0;
let totalHits = 0;
let totalClicks = 0;
let enemy = false;
let PETERFUCKINGGRIFFIN = false;
let curHomer = 1, curEnemy = 1;
let comboSizeOffset = 0.8;
let previousPerfTime = performance.now();
let gameTimerDecrementAmount = 0;
let TimerDecrementer = 0;
let gameTimer = 10;
let peterTimer = 0;
let peterTimerDecrementer = 0;
let timerJump = [0, 0]; // gameTimer, peterTimer
let scoreMultiplier = 1;
let scoreSizeAndPosShitIdk = [0, 0]

const comboDisplayValues = [1, 1, 50, 100,
  'rgba(0,0,0,1)', 'rgba(255,165,0,1)', 'rgba(0,0,0,0.5)', 'rgba(255,165,0,0.5)'];
let comboColor = comboDisplayValues[4];
let comboColorTransparent = comboDisplayValues[6];
let scoreDisplay = [0, 0]; // score, accuracy

const homiePositionsTable = [
  [180,163], [392,165], [650,150], [954,118]
];

const particles = [];
function spawnComboShatter(x, y){
  for(let i=0;i<40;i++){
    const a = Math.random()*Math.PI*2;
    const s = 200 + Math.random()*800;
    particles.push({x,y, vx:Math.cos(a)*s, vy:Math.sin(a)*s, life:1});
  }
}
function updateParticles(dt){
  for(const p of particles){
    p.vx *= 0.98; p.vy *= 0.98;
    p.x += p.vx * dt; p.y += p.vy * dt;
    p.life -= dt; 
  }
  for(let i=particles.length-1;i>=0;i--) if(particles[i].life<=0) particles.splice(i,1);
}
function drawParticles(){
  ctx.save();
  ctx.globalAlpha = 1;
  for(const p of particles){
    const a = clamp(p.life, 0, 1);
    ctx.globalAlpha = a;
    if(img.comboShatter) ctx.drawImage(img.comboShatter, p.x, p.y);
  }
  ctx.restore();
}

function playRandomMusic() {
  const musicFiles = [
    "music/Kevin MacLeod - All This.ogg",
    "music/Kevin MacLeod - Amazing Plan.ogg",
    "music/Kevin MacLeod - Arcadia.ogg",
    "music/Kevin MacLeod - Aurea Carmina.ogg",
    "music/Kevin MacLeod - Barroom Ballet.ogg",
    "music/Kevin MacLeod - Basement Floor.ogg",
    "music/Kevin MacLeod - Black Vortex.ogg",
    "music/Kevin MacLeod - Breaktime.ogg",
    "music/Kevin MacLeod - Cipher.ogg",
    "music/Kevin MacLeod - Cut and Run.ogg",
    "music/Kevin MacLeod - Dance of the Sugar Plum Fairies.ogg",
    "music/Kevin MacLeod - Darkest Child.ogg",
    "music/Kevin MacLeod - Exhilarate.ogg",
    "music/Kevin MacLeod - Fluffing a Duck.ogg",
    "music/Kevin MacLeod - Frost Waltz.ogg",
    "music/Kevin MacLeod - Gold Rush.ogg",
    "music/Kevin MacLeod - Heartbreaking.ogg",
    "music/Kevin MacLeod - Hidden Agenda.ogg",
    "music/Kevin MacLeod - Hitman.ogg",
    "music/Kevin MacLeod - Hyperfun.ogg",
    "music/Kevin MacLeod - Ice Flow.ogg",
    "music/Kevin MacLeod - Investigations.ogg",
    "music/Kevin MacLeod - Jaunty Gumption.ogg",
    "music/Kevin MacLeod - Jingle Bells.ogg",
    "music/Kevin MacLeod - Killing Time.ogg",
    "music/Kevin MacLeod - Kool Kats.ogg",
    "music/Kevin MacLeod - Local Forecast - Elevator.ogg",
    "music/Kevin MacLeod - Local Forecast.ogg",
    "music/Kevin MacLeod - Look Busy.ogg",
    "music/Kevin MacLeod - Mariachi Snooze.ogg",
    "music/Kevin MacLeod - Merry Go.ogg",
    "music/Kevin MacLeod - Mister Exposition.ogg",
    "music/Kevin MacLeod - Move Forward.ogg",
    "music/Kevin MacLeod - Movement Proposition.ogg",
    "music/Kevin MacLeod - MTA.ogg",
    "music/Kevin MacLeod - Pixel Peeker Polka - faster.ogg",
    "music/Kevin MacLeod - Quirky Dog.ogg",
    "music/Kevin MacLeod - Scheming Weasel (faster Version).ogg",
    "music/Kevin MacLeod - Sneaky Adventure.ogg",
    "music/Kevin MacLeod - Sneaky.ogg",
    "music/Kevin MacLeod - Spazzmatica Polka.ogg",
    "music/Kevin MacLeod - The Builder.ogg",
    "music/Kevin MacLeod - The Descent.ogg",
    "music/Kevin MacLeod - The House of Leaves.ogg",
    "music/Kevin MacLeod - Truth of the Legend.ogg",
    "music/Kevin MacLeod - Volatile Reaction.ogg",
    "music/Kevin MacLeod - Wallpaper.ogg",
    "music/Kevin MacLeod - Who Likes to Party.ogg",
    "music/Kevin MacLeod Archive - Kevin MacLeod： Meatball Parade.ogg",
    "music/Kevin MacLeod Archive - Kevin MacLeod： Run Amok.ogg",
    "music/Kevin MacLeod Archive - Kevin MacLeod： The Cannery.ogg",
    "music/nocturnes.mp3"
  ]
  const randomMusic = musicFiles[Math.floor(Math.random() * musicFiles.length)];
  snd.music = loadAudio(randomMusic, 1);
  snd.music.play();
  snd.music.volume = 0.1;
}

function initGame(){
  peterBonusPos[0] = -img.peterBonus.width*1.2; peterBonusPos[1] = 130; peterBonusPos[2] = -35;
  score = 0; combo = 0; highestCombo = 0; comboSizeOffset = 0.8; shakeIntensity = 0; comboTilt = 0;
  totalHits = 0; totalClicks = 0; diedBy = 'error- diedBy was never set';
  comboColor = comboDisplayValues[4]; comboColorTransparent = comboDisplayValues[6];
  scoreDisplay[0] = 0; particles.length = 0;
  scoreDisplay[1] = 0;
  curHomer = rndInt(1,4); curEnemy = 1; enemy = false;
  gameoverScreen = false; title = false;
  gameTimer = cheatActivated ? 9999 : 10;
  health = cheatActivated ? 9999 : 3;

  playRandomMusic();
}

function doGameOver(){
  if(score > highScore){ highScore = Math.floor(score); localStorage.setItem('hh_highScore', String(highScore)); }
  gameoverScreen = true;
  snd.priceIsRightLose.currentTime = 0;
  snd.priceIsRightLose.volume = 0.5
  snd.priceIsRightLose.play().catch(()=>{});
  snd.music.pause()

}

function doPeterBonusAlert(){
  try {
    if(snd.lucky){ snd.lucky.currentTime = 0; snd.lucky.play().catch(()=>{}); }
  } catch{}
  peterBonusPos[0] = -img.peterBonus.width; peterBonusPos[1] = 130; peterBonusPos[2] = -35;
  if(window._luckyTween) Timer.cancel(window._luckyTween);
  if(window._luckyTweenRotate) Timer.cancel(window._luckyTweenRotate);
  window._luckyTweenRotate = Timer.tween(1, peterBonusPos, { 2: 0 }, 'out-back');
  window._luckyTween = Timer.tween(0.8, peterBonusPos, { 0: canvas.width / 2 - img.peterBonus.width/2 }, 'out-quad', () => {
    Timer.tween(1.3, peterBonusPos, { 2: 0 }, 'out-back');
    Timer.after(1.65, () => {
      Timer.tween(0.4, peterBonusPos, { 1: -310, 2: 25 }, 'in-expo');
    });
  });
}

function incrementCombo(){
  gameTimer = cheatActivated ? 9999 : 10;
  combo += 1; comboSizeOffset += 0.01; shakeIntensity += 0.15; comboTilt = -0.1; totalHits += 1;
  if(combo >= highestCombo) highestCombo = combo;
  comboDisplayValues[0] = 1.35; comboDisplayValues[1] = 1.1;
  Timer.tween(0.35, comboDisplayValues, { 0: 1 }, 'out-quad');
  Timer.tween(0.2,  comboDisplayValues, { 1: 1 }, 'out-quad');
  comboDisplayValues[2] = 50; comboDisplayValues[3] = 100;
  score += 10 * (combo/4) * scoreMultiplier;
  if(PETERFUCKINGGRIFFIN){ 
    score *= 3; doPeterBonusAlert(); 
    scoreMultiplier += 0.5;
    peterTimer = 15;
    Timer.after(15, () => { scoreMultiplier -= 0.5; });
  } else { 
    if (snd.homerLaugh) {
        const clone = new Audio(snd.homerLaugh.src);
        clone.volume = 0.25;
        clone.playbackRate = Math.random() * 3 + 0.5;
        clone.play().catch(()=>{});
    }
  }
  // -25 - 25
  scoreSizeAndPosShitIdk[0] = (Math.random() * 50 - 25)
  scoreSizeAndPosShitIdk[1] = 1.3
  window._scoreSizeAndPosShitTween = Timer.tween(0.3, scoreSizeAndPosShitIdk, { 0: 0, 1: 1 }, 'out-quad');
  let sizeModifier = 0;
  doScoreDisplay();
}

let scoreDisplayTween = null;
function doScoreDisplay(){
  if(scoreDisplayTween) Timer.cancel(scoreDisplayTween);
  scoreDisplayTween = Timer.tween(1, scoreDisplay, { 0: score, 1: totalClicks>0 ? Math.floor((totalHits/totalClicks)*100) : 0 }, 'out-quad');
}

function checkInput(which){
  totalClicks += 1;
  if(which === curHomer){
    incrementCombo();
    pickNewHomerPos(curHomer);
  } else if(which === curEnemy){
    if (!PETERFUCKINGGRIFFIN) {
      doGameOver(); diedBy = 'Frank Grimes';
      if (snd.frankGrimes) {
          snd.frankGrimes.currentTime = 0;
          snd.frankGrimes.play().catch(()=>{});
      }
    } else {
      peterTimer = 15;
      snd.notsolucky.currentTime = 0;
      snd.notsolucky.play().catch(()=>{});
      scoreMultiplier -= 0.5;
      Timer.after(15, () => { scoreMultiplier += 0.5; });
    }
  } else {
    combo = 0; comboSizeOffset = 0.8; shakeIntensity = 0; score -= (score * 4) / 10; doScoreDisplay();
    comboColor = comboDisplayValues[4]; comboColorTransparent = comboDisplayValues[6];
    health -= 1;
    snd.grrr.currentTime = 0;
    snd.grrr.play().catch(()=>{});
    comboDisplayValues[2] = 50; comboDisplayValues[3] = 100; pickNewHomerPos(curHomer);
    if(health <= 0) doGameOver(); diedBy = 'health';
  }
}

function pickNewHomerPos(curHomerPos){
  const peterPercent = rndInt(1,10);
  const enemyPercent = rndInt(1,3);
  PETERFUCKINGGRIFFIN = (peterPercent === 1) && (peterTimer <= 0);
  if(enemyPercent === 1){ enemy = !PETERFUCKINGGRIFFIN; } else { enemy = false; }
  curHomer = rndInt(1,4);
  while(curEnemy === curHomer){ curEnemy = rndInt(1,4); }
  if(curHomer === curHomerPos){ pickNewHomerPos(curHomerPos); }
}

function checkHit(x, y){
  if(enemy && !PETERFUCKINGGRIFFIN){
    const ex = homiePositionsTable[curEnemy-1][0];
    const ey = homiePositionsTable[curEnemy-1][1];
    const w = img.homer ? img.homer.width : 64;
    const h = img.homer ? img.homer.height : 64;
    if(x>ex && x<ex+w && y>ey && y<ey+h){
      doGameOver(); diedBy = 'Frank Grimes';
      if (snd.frankGrimes) {
          snd.frankGrimes.currentTime = 0;
          snd.frankGrimes.play().catch(()=>{});
      }
      return false;
    }
  } else if (enemy && PETERFUCKINGGRIFFIN) {
    // notsolucky
    peterTimer = 15;
    snd.notsolucky.currentTime = 0;
    snd.notsolucky.play().catch(()=>{});
    scoreMultiplier -= 0.5;
    Timer.after(15, () => { scoreMultiplier += 0.5; });
  }
  const hx = homiePositionsTable[curHomer-1][0];
  const hy = homiePositionsTable[curHomer-1][1];
  const w = img.homer ? img.homer.width : 64;
  const h = img.homer ? img.homer.height : 64;
  if(x>hx && x<hx+w && y>hy && y<hy+h){ return true; }
  return false;
}

canvas.addEventListener('mousedown', ev => {
  if(title || gameoverScreen){ initGame(); return; }
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width  / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (ev.clientX - rect.left) * scaleX;
  const y = (ev.clientY - rect.top)  * scaleY;
  totalClicks += 1;
  if(checkHit(x,y)) { incrementCombo(); pickNewHomerPos(curHomer); }
  else { 
        combo = 0; comboSizeOffset = 0.8; 
        shakeIntensity = 0; 
        score -= (score * 4)/10; doScoreDisplay(); 
        comboColor = comboDisplayValues[4]; comboColorTransparent = comboDisplayValues[6]; 
        comboDisplayValues[2]=50; comboDisplayValues[3]=100; 
        health -= 1;
        if(health <= 0) doGameOver(); diedBy = 'health';

        if (!PETERFUCKINGGRIFFIN) {
          snd.grrr.currentTime = 0;
          snd.grrr.play().catch(()=>{});
        } else {
          snd.notsolucky.currentTime = 0;
          snd.notsolucky.play().catch(()=>{});
        }
        pickNewHomerPos(curHomer); 
    }
});

window.addEventListener('keydown', (e) => {
  if((title || gameoverScreen) && e.key.toLowerCase()===' '){ initGame(); }
});

let cheatBuffer = '';
let activeCheats = {};

// Define all cheats here
const cheats = {
  penis: () => {
    if (!activeCheats.penis) {
      gameTimer = 9999;
      health = 9999;
      activeCheats.penis = true;
      console.log('Cheat activated: infinite time & health!');
    } else {
      gameTimer = 10;
      health = 3;
      activeCheats.penis = false;
      console.log('Cheat deactivated: back to normal.');
    }
  }
};

window.addEventListener('keydown', (e) => {
  const key = e.key.toLowerCase();
  if (key.length === 1) {
    cheatBuffer += key;

    for (const code in cheats) {
      if (cheatBuffer.endsWith(code)) {
        cheats[code]();
        cheatBuffer = '';
        break;
      }
    }

    if (cheatBuffer.length > 20) cheatBuffer = cheatBuffer.slice(-20);
  }
});

function update(dt){
  Timer.update(dt);
  updateParticles(dt);
  gameTimerDecrementAmount = Math.min((1000+(score)), 20000);
  TimerDecrementer -= gameTimerDecrementAmount * dt;
  peterTimerDecrementer -= 1000 * dt

  if (TimerDecrementer <= 0) {
    TimerDecrementer = 1000
    gameTimer -= 1;
    timerJump[0] = -15;
    Timer.tween(0.2, timerJump, {0: 0}, "out-back");
  }

  if (peterTimerDecrementer <= 0) {
    peterTimerDecrementer = 1000;
    peterTimer -= 1;
    timerJump[1] = -15;
    Timer.tween(0.2, timerJump, {1: 0}, "out-back");
  }

  if(!title && !gameoverScreen){
    comboDisplayValues[2] = rndInt(comboDisplayValues[2]-shakeIntensity, comboDisplayValues[2]+shakeIntensity);
    comboDisplayValues[3] = rndInt(comboDisplayValues[3]-shakeIntensity, comboDisplayValues[3]+shakeIntensity);

    if(keysDownOnce['k']) checkInput(4);
    if(keysDownOnce['j']) checkInput(3);
    if(keysDownOnce['f']) checkInput(2);
    if(keysDownOnce['d']) checkInput(1);

    if (snd.music.ended) {
      playRandomMusic();
    }

    if(gameTimer <= 0){ diedBy = 'Timer'; doGameOver(); }
  }
}

let shakeBooleanIDK = false;
let otherShakeBooleanIDK = false;
let shakeX = 0, shakeY = 0;

function draw(){
  ctx.save();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(img.background) ctx.drawImage(img.background, 0, 0);

  if(!title && !gameoverScreen){
    for(let i=1;i<=4;i++){
      const pos = homiePositionsTable[i-1];
      if(!enemy){ if(i !== curHomer){ if(img.homie) ctx.drawImage(img.homie, pos[0], pos[1]); } }
      else { if(i !== curHomer && i !== curEnemy){ if(img.homie) ctx.drawImage(img.homie, pos[0], pos[1]); } }
    }

    for(let i=1;i<=health;i++){
      const x = (i===1)? canvas.width-75 : (i===2? canvas.width-50 : canvas.width-25);
      if(img.healthIcon) ctx.drawImage(img.healthIcon, x, 50);
    }

    if(!PETERFUCKINGGRIFFIN){
      if(img.homer) ctx.drawImage(img.homer, homiePositionsTable[curHomer-1][0], homiePositionsTable[curHomer-1][1]);
      if(enemy && img.frank) ctx.drawImage(img.frank, homiePositionsTable[curEnemy-1][0], homiePositionsTable[curEnemy-1][1]);
    } else {
      if(img.chicken) ctx.drawImage(img.chicken, homiePositionsTable[curEnemy-1][0], homiePositionsTable[curEnemy-1][1]);
      if(img.peter)   ctx.drawImage(img.peter,   homiePositionsTable[curHomer-1][0], homiePositionsTable[curHomer-1][1]);
    }

    ctx.globalAlpha = peterBonusPos[1];
    if(img.peterBonus)  {
      const cx = peterBonusPos[0] + 15;
      const cy = peterBonusPos[1] + img.peterBonus.height / 2;

      ctx.translate(cx, cy);
      ctx.rotate(peterBonusPos[2] * Math.PI / 180);
      ctx.scale(0.7, 0.7);
      ctx.translate(-cx, -cy);

      ctx.drawImage(img.peterBonus, peterBonusPos[0], peterBonusPos[1]);

      ctx.translate(cx, cy);
      ctx.rotate(-peterBonusPos[2] * Math.PI / 180);
      ctx.scale(1/0.7, 1/0.7);
      ctx.translate(-cx, -cy);
    }
    ctx.globalAlpha = 1;

    drawParticles();

    shakeBooleanIDK = !shakeBooleanIDK;
    otherShakeBooleanIDK = !otherShakeBooleanIDK;
    if (otherShakeBooleanIDK)
      if (shakeBooleanIDK) {
        // 0 -> score/1000 random
        shakeX = (Math.random() * 2 - 1) * (score / 1000);
        shakeY = (Math.random() * 2 - 1) * (score / 1000);
      } else {
        shakeX = -shakeX;
        shakeY = -shakeY;
      }

    ctx.fillStyle = '#000';
    ctx.font = '75px FATASSOU, sans-serif';
    // actually gotta rotate it -5 deg
    ctx.translate(100 + shakeX + scoreSizeAndPosShitIdk[0], 150 + shakeY + scoreSizeAndPosShitIdk[0]);
    ctx.rotate(-5 * Math.PI / 180);
    ctx.scale(scoreSizeAndPosShitIdk[1], scoreSizeAndPosShitIdk[1]);
    ctx.translate(-100 - shakeX - scoreSizeAndPosShitIdk[0], -100 - shakeY - scoreSizeAndPosShitIdk[0]);
    ctx.fillText(`${Math.floor(scoreDisplay[0])}`, 100 + shakeX + scoreSizeAndPosShitIdk[0], 100 + shakeY + scoreSizeAndPosShitIdk[0]);
    ctx.translate(100 + shakeX + scoreSizeAndPosShitIdk[0], 100 + shakeY + scoreSizeAndPosShitIdk[0]);
    ctx.rotate(5 * Math.PI / 180);
    // reset scale
    ctx.scale(1/scoreSizeAndPosShitIdk[1], 1/scoreSizeAndPosShitIdk[1]);
    ctx.translate(-100 - shakeX - scoreSizeAndPosShitIdk[0], -100 - shakeY - scoreSizeAndPosShitIdk[0]);
    ctx.textAlign = 'right';
    ctx.font = '50px FATASSOU, sans-serif';
    ctx.fillText(`${Math.floor(gameTimer)}`, canvas.width/2, 120 + timerJump[0]);

    if(peterTimer > 0) ctx.fillText(`${Math.floor(peterTimer)}`, canvas.width/2 + 300, 120 + timerJump[1]);
    ctx.textAlign = 'left';

    ctx.font = '50px FATASSOU, sans-serif';
    // display acc to TWO decimal places
    ctx.fillText(`${Math.ceil(scoreDisplay[1])}%`, 100, 600);
    
  }

  if(gameoverScreen){
    ctx.fillStyle = 'rgba(255,0,0,0.5)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = '80px FATASSOU, sans-serif';
    const msg = (score < 8075791209) ? 'lmao you suck' : 'balls';
    drawCentered(msg, 140);

    ctx.font = '40px SEGOEPRB, sans-serif';
    drawCentered(`High Score- ${highScore}`, 250);
    drawCentered(`Your Score- ${Math.floor(score)}`, 300);
    drawCentered(`Highest Combo- ${highestCombo}`, 350);
    const acc = totalClicks>0 ? Math.floor((totalHits/totalClicks)*100) : 0;
    drawCentered(`Accuracy- ${acc}%`, 400);
    drawCentered(`Died By- ${diedBy}`, 450);

    ctx.save();
    ctx.translate(canvas.width/2 - 110, 500);
    ctx.scale(1.2,1.2);
    drawCentered('Press [SPACE] or press screen', -600);
    ctx.restore();
  }

  if(title){
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = '40px SEGOEPRB, sans-serif';
    ctx.save();
    ctx.drawImage(img.tutorial, 0, 0);
    ctx.restore();
  }

  ctx.restore();
}

function drawCentered(text, y){
  const metrics = ctx.measureText(text);
  const x = (canvas.width - metrics.width)/2;
  ctx.fillText(text, x, y);
}

let health = 3;

const keyHeld = new Set();
const keysDownOnce = {};
window.addEventListener('keydown', e => { keyHeld.add(e.key.toLowerCase()); });
window.addEventListener('keyup',   e => { keyHeld.delete(e.key.toLowerCase()); });
function collectKeyEdges(){
  const desired = ['d','f','j','k'];
  for(const k of desired){
    if(keyHeld.has(k)){
      keysDownOnce[k] = !keysDownOnce[`__held_${k}`];
      keysDownOnce[`__held_${k}`] = true;
    } else {
      keysDownOnce[k] = false;
      keysDownOnce[`__held_${k}`] = false;
    }
  }
}

function loop(now){
  const dt = Math.min(0.033, (now - previousPerfTime)/1000);
  previousPerfTime = now;
  collectKeyEdges();
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

(async function(){
  await preload();
  requestAnimationFrame(loop);
})();
  </script>
</body>
</html>